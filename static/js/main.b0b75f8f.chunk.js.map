{"version":3,"sources":["Icons/githubicon.svg","Icons/reset.svg","Icons/new.svg","Icons/visible.svg","Icons/hide.svg","logo.svg","Components/Header/header.js","Components/Cell/cell.js","Components/Row/row.js","Components/Board/board.js","Components/PickupCell/pickupcell.js","Components/CellPickupBar/cellpickupbar.js","Components/ResetBoard/resetboard.js","Components/GenerateBoard/generateboard.js","Components/Solution/solution.js","Components/HowToPlay/howtoplay.js","Components/GameArena/gamearena.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","Header","props","className","href","src","GithubIcon","alt","React","Component","Cell","onDragOver","bind","event","preventDefault","this","cellValue","rowNumber","columnNumber","highlight","fixed","error","onDrop","onDragEnter","onDragLeave","Math","floor","push","join","Row","boardSize","cellValues","cells","i","key","Board","board","isSudokuSolved","showSolutionBoard","rows","PickupCell","onDragStart","onDragEnd","dataTransfer","effectAllowed","setData","target","style","opacity","draggable","CellPickupBar","ResetBoard","onResetBoard","onClick","ResetIcon","GenerateBoard","onNewGame","NewGameIcon","Solution","showSolution","HideIcon","VisibleIcon","HowToPlay","GameArena","getEmptyBoard","findError","generateBoard","solveSudoku","isMultipleSolutionsPossible","shuffleArray","isValidBoard","createNewGame","j","solutionBoard","Array","slice","state","storeBoard","storeError","solutionsFound","fillValue","fill","setState","newBoard","indices","BOARD_SIZE","cellsRemaining","index","store","passBoard","x","y","values","value","squareBlockStartX","squareBlockStartY","array","length","random","temp","newErrorBoard","rowMap","Map","has","get","set","columnMap","blockMaps","mapIndex","rowSet","Set","add","size","columnSet","blockSets","stopPropagation","valueToPut","getData","parseInt","toHighlight","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","console","message"],"mappings":"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","file":"static/js/main.b0b75f8f.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/githubicon.a2594cec.svg\";","module.exports = __webpack_public_path__ + \"static/media/reset.a5b1200b.svg\";","module.exports = __webpack_public_path__ + \"static/media/new.1e7b53c1.svg\";","module.exports = __webpack_public_path__ + \"static/media/visible.ad95b87b.svg\";","module.exports = __webpack_public_path__ + \"static/media/hide.fbd6c8ea.svg\";","module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","import React from 'react';\r\nimport GithubIcon from '../../Icons/githubicon.svg';\r\nimport './header.css';\r\n\r\nclass Header extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div className = \"header\">\r\n                <h2 className = \"title\">SUDOKU</h2>\r\n                <a href = \"https://github.com/VaibhavDomadia/sudoku\" className = \"githubIcon\">\r\n                    <img src = {GithubIcon} alt = \"Github Icon\"></img>\r\n                </a>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default Header;","import React from 'react';\r\nimport './cell.css';\r\n\r\nclass Cell extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.onDragOver = this.onDragOver.bind(this);\r\n    }\r\n\r\n    onDragOver(event) {\r\n        if(event.preventDefault) {\r\n            event.preventDefault();\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    render() {\r\n        let {cellValue, rowNumber, columnNumber, highlight, fixed, error, onDrop, onDragEnter, onDragLeave} = this.props;\r\n\r\n        let className = ['cell'];\r\n\r\n        let blockNumber = Math.floor(rowNumber/3)*3 + Math.floor(columnNumber/3) + 1;\r\n\r\n        if(blockNumber%2 === 0) {\r\n            className.push('cellLight');\r\n        }\r\n        else {\r\n            className.push('cellDark')\r\n        }\r\n        \r\n        if(highlight) {\r\n            className.push('highlight');\r\n        }\r\n        \r\n        if(fixed) {\r\n            className.push('fixed');\r\n        }\r\n\r\n        if(error) {\r\n            className.push('error');\r\n        }\r\n\r\n        return (\r\n            <div>\r\n                {\r\n                    fixed ? <div className = {className.join(' ')}>\r\n                        {cellValue === 0 ? \"\" : cellValue}\r\n                    </div> :\r\n                    <div className = {className.join(' ')} onDrop = {event => onDrop(event, rowNumber, columnNumber)} onDragOver = {this.onDragOver} onDragEnter = {event => onDragEnter(event, rowNumber, columnNumber)} onDragLeave = {event => onDragLeave(event, rowNumber, columnNumber)}>\r\n                        {cellValue === 0 ? \"\" : cellValue}\r\n                    </div>\r\n                }\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default Cell;","import React from 'react';\r\nimport './row.css';\r\nimport Cell from '../Cell/cell';\r\n\r\nclass Row extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n    }\r\n\r\n    render() {\r\n        let {boardSize, rowNumber, cellValues, highlight, fixed, error, onDrop, onDragEnter, onDragLeave} = this.props;\r\n\r\n        let cells = [];\r\n        for(let i=0 ; i<boardSize ; i++) {\r\n            cells.push(<Cell key = {i} rowNumber = {rowNumber} columnNumber = {i} cellValue = {cellValues[i]} highlight = {highlight[i]} fixed = {fixed[i]} error = {error[i]} onDrop = {onDrop} onDragEnter = {onDragEnter} onDragLeave = {onDragLeave}/>);\r\n        }\r\n\r\n        return (\r\n            <div className = \"row\">\r\n                {cells}\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default Row;","import React from 'react';\r\nimport './board.css';\r\nimport Row from '../Row/row';\r\n\r\nclass Board extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n    }\r\n\r\n    render() {\r\n        let {boardSize, board, highlight, fixed, error, isSudokuSolved, showSolutionBoard, onDrop, onDragEnter, onDragLeave} = this.props;\r\n\r\n        let rows = [];\r\n        for(let i=0 ; i<boardSize ; i++) {\r\n            rows.push(<Row key = {i} rowNumber = {i} boardSize = {boardSize} cellValues = {board[i]} highlight = {highlight[i]} fixed = {fixed[i]} error = {error[i]} onDrop = {onDrop} onDragEnter = {onDragEnter} onDragLeave = {onDragLeave}/>);\r\n        }\r\n\r\n        return (\r\n            <div className = \"boardContainer\">\r\n                {showSolutionBoard && <div className = \"disableDragAndDrop\"></div>}\r\n                {!showSolutionBoard && isSudokuSolved && <h2 className = \"solvedBanner\">Sudoku Solved!</h2>}\r\n                <div className = \"board\">\r\n                    {rows}\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default Board;","import React from 'react';\r\nimport './pickupcell.css';\r\n\r\nclass PickupCell extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.onDragStart = this.onDragStart.bind(this);\r\n        this.onDragEnd = this.onDragEnd.bind(this);\r\n    }\r\n\r\n    /**\r\n     * This function gets called on dragging a cell.\r\n     * It set's the opacity of dragged cell to 0.4, as to show the visual effect of being dragged.\r\n     * \r\n     * @param event \r\n     */\r\n    onDragStart(event) {\r\n        event.dataTransfer.effectAllowed = 'move';\r\n        event.dataTransfer.setData('text/html', this.props.cellValue);\r\n        event.target.style.opacity = '0.4';\r\n    }\r\n\r\n    /**\r\n     * This function gets called when the dragging of cell ends.\r\n     * It set's the opacity of dragged cell back to 1.\r\n     * \r\n     * @param event \r\n     */\r\n    onDragEnd(event) {\r\n        event.target.style.opacity = '1';\r\n    }\r\n\r\n    render() {\r\n        let {cellValue} = this.props;\r\n\r\n        return (\r\n            <div className = \"pickupCell\" draggable onDragStart = {this.onDragStart} onDragEnd = {this.onDragEnd}>\r\n                {cellValue === 0 ? \"\" : cellValue}\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default PickupCell;","import React from 'react';\r\nimport './cellpickupbar.css';\r\nimport PickupCell from '../PickupCell/pickupcell';\r\n\r\nclass CellPickupBar extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n    }\r\n\r\n    render() {\r\n        let cells = [];\r\n        for(let i=0 ; i<10 ; i++) {\r\n            cells.push(<PickupCell key = {i} cellValue = {i}/>);\r\n        }\r\n        return (\r\n            <div className = \"cellPickupBar\">\r\n                {cells}\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default CellPickupBar;","import React from 'react';\r\nimport './resetboard.css';\r\nimport ResetIcon from '../../Icons/reset.svg';\r\n\r\nclass ResetBoard extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n    }\r\n\r\n    render() {\r\n        let {onResetBoard} = this.props;\r\n\r\n        return (\r\n            <button onClick = {onResetBoard} className = \"resetBoard\">\r\n                <img src = {ResetIcon} alt = \"Reset Board\"></img>\r\n                <div>Reset Board</div>\r\n            </button>\r\n        );\r\n    }\r\n}\r\n\r\nexport default ResetBoard;\r\n","import React from 'react';\r\nimport './generateboard.css';\r\nimport NewGameIcon from '../../Icons/new.svg'\r\n\r\nclass GenerateBoard extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n    }\r\n\r\n    render() {\r\n        let {onNewGame} = this.props;\r\n\r\n        return (\r\n            <button onClick = {onNewGame} className = \"newGame\">\r\n                <img src = {NewGameIcon} alt = \"New Game\"></img>\r\n                <div>New Game</div>\r\n            </button>\r\n        );\r\n    }\r\n}\r\n\r\nexport default GenerateBoard;","import React from 'react';\r\nimport './solution.css';\r\nimport VisibleIcon from '../../Icons/visible.svg';\r\nimport HideIcon from '../../Icons/hide.svg';\r\n\r\nclass Solution extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n    }\r\n\r\n    render() {\r\n        let {showSolution, showSolutionBoard} = this.props;\r\n\r\n        return (\r\n            <button onClick = {showSolution} className = \"showSolution\">\r\n                <img src = {showSolutionBoard ? HideIcon : VisibleIcon} alt = \"Solution\"></img>\r\n                <div>{showSolutionBoard ? 'Hide Solution' : 'Show Solution'}</div>\r\n            </button>\r\n        );\r\n    }\r\n}\r\n\r\nexport default Solution;","import React from 'react';\r\nimport './howtoplay.css';\r\n\r\nclass HowToPlay extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div className = \"howToPlay\">\r\n                <h2>How To Play</h2>\r\n                <div>Drag and Drop Cells to Board</div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default HowToPlay;","import React from 'react';\r\nimport './gamearena.css';\r\nimport Board from '../Board/board';\r\nimport CellPickupBar from '../CellPickupBar/cellpickupbar';\r\nimport ResetBoard from '../ResetBoard/resetboard';\r\nimport GenerateBoard from '../GenerateBoard/generateboard';\r\nimport Solution from '../Solution/solution';\r\nimport HowToPlay from '../HowToPlay/howtoplay';\r\n\r\nconst BOARD_SIZE = 9;\r\n\r\nclass GameArena extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.getEmptyBoard = this.getEmptyBoard.bind(this);\r\n        this.onDrop = this.onDrop.bind(this);\r\n        this.onDragEnter = this.onDragEnter.bind(this);\r\n        this.onDragLeave = this.onDragLeave.bind(this);\r\n        this.findError = this.findError.bind(this);\r\n        this.isSudokuSolved = this.isSudokuSolved.bind(this);\r\n        this.generateBoard = this.generateBoard.bind(this);\r\n        this.solveSudoku = this.solveSudoku.bind(this);\r\n        this.isMultipleSolutionsPossible = this.isMultipleSolutionsPossible.bind(this);\r\n        this.shuffleArray = this.shuffleArray.bind(this);\r\n        this.isValidBoard = this.isValidBoard.bind(this);\r\n        this.createNewGame = this.createNewGame.bind(this);\r\n        this.onResetBoard = this.onResetBoard.bind(this);\r\n        this.showSolution = this.showSolution.bind(this);\r\n\r\n        let board = this.generateBoard();\r\n        let fixed = this.getEmptyBoard(false);\r\n        for(let i=0 ; i<BOARD_SIZE ; i++) {\r\n            for(let j=0 ; j<BOARD_SIZE ; j++) {\r\n                if(board[i][j] !== 0) {\r\n                    fixed[i][j] = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        let solutionBoard = new Array(BOARD_SIZE);\r\n        for(let i=0 ; i<BOARD_SIZE ; i++) {\r\n            solutionBoard[i] = board[i].slice();\r\n        }\r\n\r\n        this.solveSudoku(solutionBoard, 0, 0);\r\n\r\n        this.state = {\r\n            board: board,\r\n            highlight: this.getEmptyBoard(false),\r\n            fixed: fixed,\r\n            error: this.getEmptyBoard(false),\r\n            isSudokuSolved: false,\r\n            solutionBoard: solutionBoard,\r\n            showSolutionBoard: false\r\n        }\r\n\r\n        this.storeBoard = this.getEmptyBoard(0);\r\n        this.storeError = this.getEmptyBoard(false);\r\n        this.solutionsFound = 0;\r\n    }\r\n\r\n    /**\r\n     * It generates a 9 * 9 board of values filled with fillValue, which is passed as parameter.\r\n     * \r\n     * @param fillValue value to fill the board with.\r\n     * \r\n     * @returns board filled with fillValue.\r\n     */\r\n    getEmptyBoard(fillValue) {\r\n        let board = new Array(BOARD_SIZE);\r\n        for(let i=0 ; i<BOARD_SIZE ; i++) {\r\n            board[i] = new Array(BOARD_SIZE).fill(fillValue);\r\n        }\r\n\r\n        return board;\r\n    }\r\n\r\n    /**\r\n     * It creates new game by generating a new sudoku puzzle having a unique solution.\r\n     * It sets the error board to false and also set the solution board to the solution of the puzzle.\r\n     */\r\n    createNewGame() {\r\n        let board = this.generateBoard();\r\n        let fixed = this.getEmptyBoard(false);\r\n        for(let i=0 ; i<BOARD_SIZE ; i++) {\r\n            for(let j=0 ; j<BOARD_SIZE ; j++) {\r\n                if(board[i][j] !== 0) {\r\n                    fixed[i][j] = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        let solutionBoard = new Array(BOARD_SIZE);\r\n        for(let i=0 ; i<BOARD_SIZE ; i++) {\r\n            solutionBoard[i] = board[i].slice();\r\n        }\r\n        this.solveSudoku(solutionBoard, 0, 0);\r\n\r\n        this.setState({board: board, fixed: fixed, highlight: this.getEmptyBoard(false), error: this.getEmptyBoard(false), isSudokuSolved: false, solutionBoard: solutionBoard, showSolutionBoard: false});\r\n    }\r\n\r\n    /**\r\n     * It sets the game to the state where it was in the beggining of the puzzle.\r\n     * Only fixed values remains, rest all the values entered by player is cleared.\r\n     */\r\n    onResetBoard() {\r\n        let {board, fixed} = this.state;\r\n        let newBoard = this.getEmptyBoard(0);\r\n\r\n        for(let i=0 ; i<BOARD_SIZE ; i++) {\r\n            for(let j=0 ; j<BOARD_SIZE ; j++) {\r\n                if(fixed[i][j]) {\r\n                    newBoard[i][j] = board[i][j];\r\n                }\r\n            }\r\n        }\r\n\r\n        this.setState({board: newBoard, fixed: fixed, highlight: this.getEmptyBoard(false), error: this.getEmptyBoard(false), isSudokuSolved: false});\r\n    }\r\n\r\n    /**\r\n     * It toggles between showing the solution and hiding it.\r\n     * If the state showSolutionBoard is true then it hides the solution on next function call.\r\n     * Else it display the solution board on next function call.\r\n     */\r\n    showSolution() {\r\n        if(this.state.showSolutionBoard) {\r\n            let board = this.getEmptyBoard(0);\r\n            let error = this.getEmptyBoard(false);\r\n            for(let i=0 ; i<BOARD_SIZE ; i++) {\r\n                for(let j=0 ; j<BOARD_SIZE ; j++) {\r\n                    board[i][j] = this.storeBoard[i][j];\r\n                    error[i][j] = this.storeError[i][j];\r\n                }\r\n            }\r\n\r\n            this.setState({board: board, error: error, showSolutionBoard: false});\r\n        }\r\n        else {\r\n            for(let i=0 ; i<BOARD_SIZE ; i++) {\r\n                for(let j=0 ; j<BOARD_SIZE ; j++) {\r\n                    this.storeBoard[i][j] = this.state.board[i][j];\r\n                    this.storeError[i][j] = this.state.error[i][j];\r\n                }\r\n            }\r\n\r\n            this.setState({board: this.state.solutionBoard, error: this.getEmptyBoard(false), showSolutionBoard: true});\r\n        }\r\n    }\r\n\r\n    /**\r\n     * It generated the initial state of the sudoku game.\r\n     * \r\n     * First using empty sudoku board it is solved by using backtracking algorithm.\r\n     * Then removing the cell one by one from the board and to ensure that sudoku has unique solution\r\n     * it backtracks again to check if multiple solutions to the current state of board exists or not.\r\n     */\r\n    generateBoard() {\r\n        let board = this.getEmptyBoard(0);\r\n        this.solveSudoku(board, 0, 0);\r\n\r\n        let indices = new Array(BOARD_SIZE * BOARD_SIZE);\r\n        for(let i=0 ; i<BOARD_SIZE * BOARD_SIZE ; i++) {\r\n            indices[i] = i;\r\n        }\r\n\r\n        this.shuffleArray(indices);\r\n\r\n        let cellsRemaining = BOARD_SIZE * BOARD_SIZE;\r\n        for(let i=BOARD_SIZE * BOARD_SIZE - 1 ; i>=20 && cellsRemaining > 20 ; i--) {\r\n            let index = indices[i];\r\n            let store = board[Math.floor(index / BOARD_SIZE)][index % BOARD_SIZE];\r\n            board[Math.floor(index / BOARD_SIZE)][index % BOARD_SIZE] = 0;\r\n            \r\n            let passBoard = new Array(BOARD_SIZE);\r\n            for(let j=0 ; j<BOARD_SIZE ; j++) {\r\n                passBoard[j] = board[j].slice();\r\n            }\r\n            \r\n            this.solutionsFound = 0;\r\n            this.isMultipleSolutionsPossible(passBoard, 0, 0);\r\n            if(this.solutionsFound === 1) {\r\n                cellsRemaining--;\r\n            }\r\n            else {\r\n                board[Math.floor(index / BOARD_SIZE)][index % BOARD_SIZE] = store;\r\n            }\r\n        }\r\n\r\n        return board;\r\n    }\r\n\r\n    /**\r\n     * It is a recursive function to check whether the given sudoku board consist of multiple solution or not.\r\n     * \r\n     * @param board the board to check for possibility of multiple solutions.\r\n     * @param x the row number of the cell in the board.\r\n     * @param y the column number of the cell in the board.\r\n     * \r\n     * @returns 1 if the sudoku has unique solution, 2 if the sudoku has multiple solutions.\r\n     */\r\n    isMultipleSolutionsPossible(board, x, y) {\r\n\r\n        if(y === BOARD_SIZE) {\r\n            x++;\r\n            y = 0;\r\n        }\r\n\r\n        if(x === BOARD_SIZE) {\r\n            this.solutionsFound++;\r\n            return;\r\n        }\r\n\r\n        if(board[x][y] !== 0) {\r\n            this.isMultipleSolutionsPossible(board, x, y+1);\r\n            return;\r\n        }\r\n\r\n        for(let i=0 ; i<BOARD_SIZE ; i++) {\r\n            if(this.isValidBoard(board, x, y, i+1)) {\r\n                board[x][y] = i+1;\r\n                this.isMultipleSolutionsPossible(board, x, y+1);\r\n                if(this.solutionsFound > 1) {\r\n                    return;\r\n                }\r\n                board[x][y] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * It is a recursive function to generate the solution of the sudoku.\r\n     * \r\n     * @param board the sudoku board whose solution has to be found out.\r\n     * @param x the row number of the cell in the board.\r\n     * @param y the column number of the cell in the board.\r\n     */\r\n    solveSudoku(board, x, y) {\r\n\r\n        if(y === BOARD_SIZE) {\r\n            x++;\r\n            y = 0;\r\n        }\r\n\r\n        if(x === BOARD_SIZE) {\r\n            return true;\r\n        }\r\n\r\n        if(board[x][y] !== 0) {\r\n            return this.solveSudoku(board, x, y+1);\r\n        }\r\n\r\n        let values = new Array(BOARD_SIZE);\r\n        for(let i=0 ; i<BOARD_SIZE ; i++) {\r\n            values[i] = i+1;\r\n        }\r\n        this.shuffleArray(values);\r\n\r\n        for(let i=0 ; i<BOARD_SIZE ; i++) {\r\n            if(this.isValidBoard(board, x, y, values[i])) {\r\n                board[x][y] = values[i];\r\n                if(this.solveSudoku(board, x, y+1)) {\r\n                    return true;\r\n                }\r\n                else {\r\n                    board[x][y] = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * It checks whether after putting the value to the x'th row, y'th column cell of board it is still\r\n     * a valid sudoku board or not.\r\n     * \r\n     * @param board the sudoku board to check the validity\r\n     * @param x the row number of the cell in the board.\r\n     * @param y the column number of the cell in the board.\r\n     * @param value value that is going to be put on xth row, yth column.\r\n     * \r\n     * @returns true if it is still a valid board, false otherwise.\r\n     */\r\n    isValidBoard(board, x, y, value) {\r\n        for(let i=0 ; i<BOARD_SIZE ; i++) {\r\n            if(board[x][i] === value) {\r\n                return false;\r\n            }\r\n            if(board[i][y] === value) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        let squareBlockStartX = x - (x%3);\r\n        let squareBlockStartY = y - (y%3);\r\n        for(let i=squareBlockStartX ; i<squareBlockStartX+3 ; i++) {\r\n            for(let j=squareBlockStartY ; j<squareBlockStartY+3 ; j++) {\r\n                if(board[i][j] === value) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * It shuffles the array passed as an input.\r\n     * \r\n     * @param array the array to be shuffled.\r\n     */\r\n    shuffleArray(array) {\r\n        for(let i=array.length-1 ; i>=0 ; i--) {\r\n            let index = Math.floor(Math.random() * (i+1));\r\n\r\n            let temp = array[index];\r\n            array[index] = array[i];\r\n            array[i] = temp;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * It checks for the collisions of cell values in a row, column or block and set the state\r\n     * error to highlight those collision on board.\r\n     * \r\n     * @param board the board to look for errors.\r\n     */\r\n    findError(board) {\r\n        let newErrorBoard = this.getEmptyBoard(false);\r\n\r\n        for(let i=0 ; i<BOARD_SIZE ; i++) {\r\n            let rowMap = new Map();\r\n            for(let j=0 ; j<BOARD_SIZE ; j++) {\r\n                if(board[i][j] !== 0) {\r\n                    if(rowMap.has(board[i][j])) {\r\n                        let index = rowMap.get(board[i][j]);\r\n                        newErrorBoard[i][index] = true;\r\n                        newErrorBoard[i][j] = true;\r\n                    }\r\n                    else {\r\n                        rowMap.set(board[i][j], j);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        for(let j=0 ; j<BOARD_SIZE ; j++) {\r\n            let columnMap = new Map();\r\n            for(let i=0 ; i<BOARD_SIZE ; i++) {\r\n                if(board[i][j] !== 0) {\r\n                    if(columnMap.has(board[i][j])) {\r\n                        let index = columnMap.get(board[i][j]);\r\n                        newErrorBoard[index][j] = true;\r\n                        newErrorBoard[i][j] = true;\r\n                    }\r\n                    else {\r\n                        columnMap.set(board[i][j], i);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        let blockMaps = new Array(BOARD_SIZE);\r\n        for(let i=0 ; i<BOARD_SIZE ; i++) {\r\n            blockMaps[i] = new Map();\r\n        }\r\n\r\n        for(let i=0 ; i<BOARD_SIZE ; i++) {\r\n            for(let j=0 ; j<BOARD_SIZE ; j++) {\r\n                if(board[i][j] !== 0) {\r\n                    let mapIndex = (Math.floor(i/3)*3) + (Math.floor(j/3));\r\n                    if(blockMaps[mapIndex].has(board[i][j])) {\r\n                        let index = blockMaps[mapIndex].get(board[i][j]);\r\n                        newErrorBoard[Math.floor(index / BOARD_SIZE)][index % BOARD_SIZE] = true;\r\n                        newErrorBoard[i][j] = true;\r\n                    }\r\n                    else {\r\n                        blockMaps[mapIndex].set(board[i][j], i*BOARD_SIZE + j);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return newErrorBoard;\r\n    }\r\n\r\n    /**\r\n     * It checks whether the input board is completely solved or not.\r\n     * \r\n     * @param board the sudoku board to look for complete state of the board.\r\n     * \r\n     * @returns true if the board is solved completely, false otherwise.\r\n     */\r\n    isSudokuSolved(board) {\r\n        for(let i=0 ; i<BOARD_SIZE ; i++) {\r\n            let rowSet = new Set();\r\n            for(let j=0 ; j<BOARD_SIZE ; j++) {\r\n                if(board[i][j] !== 0) {\r\n                    rowSet.add(board[i][j]);\r\n                }\r\n            }\r\n\r\n            if(rowSet.size !== BOARD_SIZE) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        for(let j=0 ; j<BOARD_SIZE ; j++) {\r\n            let columnSet = new Set();\r\n            for(let i=0 ; i<BOARD_SIZE ; i++) {\r\n                if(board[i][j] !== 0) {\r\n                    columnSet.add(board[i][j]);\r\n                }\r\n            }\r\n\r\n            if(columnSet.size !== BOARD_SIZE) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        let blockSets = new Array(BOARD_SIZE);\r\n        for(let i=0 ; i<BOARD_SIZE ; i++) {\r\n            blockSets[i] = new Set();\r\n        }\r\n\r\n        for(let i=0 ; i<BOARD_SIZE ; i++) {\r\n            for(let j=0 ; j<BOARD_SIZE ; j++) {\r\n                if(board[i][j] !== 0) {\r\n                    let setIndex = (Math.floor(i/3)*3) + Math.floor(j/3);\r\n                    blockSets[setIndex].add(board[i][j]);\r\n                }\r\n            }\r\n        }\r\n\r\n        for(let i=0 ; i<BOARD_SIZE ; i++) {\r\n            if(blockSets[i].size !== BOARD_SIZE) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * It gets called when the dragged cell is droped on a target.\r\n     * \r\n     * @param event drop event.\r\n     * @param x row number on which the dragged cell is dropped.\r\n     * @param y column number on which the dragged cell is dropped.\r\n     */\r\n    onDrop(event, x, y) {\r\n        event.stopPropagation();\r\n        event.target.style.opacity = \"1\";\r\n\r\n        let value = event.dataTransfer.getData('text/html');\r\n\r\n        let valueToPut;\r\n        if(value === \"\") {\r\n            valueToPut = 0;\r\n        }\r\n        else {\r\n            valueToPut = parseInt(value);\r\n        }\r\n\r\n        let newBoard = new Array(BOARD_SIZE);\r\n        for(let i=0 ; i<BOARD_SIZE ; i++) {\r\n            newBoard[i] = this.state.board[i].slice();\r\n        }\r\n        newBoard[x][y] = valueToPut;\r\n\r\n        let newErrorBoard = this.findError(newBoard);\r\n\r\n        let isSudokuSolved = this.isSudokuSolved(newBoard);\r\n        \r\n        this.setState({board: newBoard, highlight: this.getEmptyBoard(false), error: newErrorBoard, isSudokuSolved: isSudokuSolved});\r\n    }\r\n\r\n    /**\r\n     * It highlights the cell that are either in the same row, column or block of the cell on which\r\n     * the dragged item is currenly hovering.\r\n     * \r\n     * @param event drag enter event.\r\n     * @param x row number on which the dragged cell is dropped.\r\n     * @param y column number on which the dragged cell is dropped.\r\n     */\r\n    onDragEnter(event, x, y) {\r\n        let toHighlight = this.getEmptyBoard(false);\r\n        event.target.style.opacity = \"0.4\";\r\n\r\n        for(let index = 0 ; index < 9 ; index++) {\r\n            toHighlight[x][index] = true;\r\n            toHighlight[index][y] = true;\r\n        }\r\n\r\n        let squareBlockStartX = x - (x%3);\r\n        let squareBlockStartY = y - (y%3);\r\n        for(let i=squareBlockStartX ; i<squareBlockStartX+3 ; i++) {\r\n            for(let j=squareBlockStartY ; j<squareBlockStartY+3 ; j++) {\r\n                toHighlight[i][j] = true;\r\n            }\r\n        }\r\n\r\n        this.setState({highlight: toHighlight});\r\n    }\r\n\r\n    /**\r\n     * It stops highlighting the cell that are set to highlight in on drag enter event.\r\n     * \r\n     * @param event drag leave event.\r\n     * @param x row number on which the dragged cell is dropped.\r\n     * @param y column number on which the dragged cell is dropped.\r\n     */\r\n    onDragLeave(event, x, y) {\r\n        event.target.style.opacity = \"1\";\r\n        this.setState({highlight: this.getEmptyBoard(false)});\r\n    }\r\n\r\n    render() {\r\n        let {board, highlight, fixed, error, isSudokuSolved, showSolutionBoard} = this.state;\r\n\r\n        return (\r\n            <div className = \"gameArena\">\r\n                <HowToPlay/>\r\n                <div className = \"dragAndDropContainer\">\r\n                    <CellPickupBar/>\r\n                    <Board boardSize = {BOARD_SIZE} board = {board} highlight = {highlight} fixed = {fixed} error = {error} isSudokuSolved = {isSudokuSolved} showSolutionBoard = {showSolutionBoard} onDrop = {this.onDrop} onDragEnter = {this.onDragEnter} onDragLeave = {this.onDragLeave}/>\r\n                </div>\r\n                <div className = \"controls\">\r\n                    <ResetBoard onResetBoard = {this.onResetBoard}/>\r\n                    <GenerateBoard onNewGame = {this.createNewGame}/>\r\n                    <Solution showSolution = {this.showSolution} showSolutionBoard = {showSolutionBoard}/>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default GameArena;","import React from 'react';\r\nimport logo from './logo.svg';\r\nimport './App.css';\r\nimport Header from './Components/Header/header';\r\nimport GameArena from './Components/GameArena/gamearena';\r\n\r\nclass App extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div>\r\n                <Header/>\r\n                <GameArena/>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}